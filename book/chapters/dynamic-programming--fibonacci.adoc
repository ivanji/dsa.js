= Fibonacci Sequence with Dynamic Programming

To illustrate how we can solve problems faster using dynamic programming. Let's say you want a program to find the n-th fibonacci number.

.Fibonacci Numbers
****
Fibancci sequence is a serie of numbers that starts with `0, 1`, the next values are calculated as the sum of the previous two. So, we have:

`0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...`
****

We can get the nth fibonacci number with the following recursive program:

.Recursive Fibonacci implemenation
[source, javascript]
----
include::{codedir}/algorithms/fibonacci-recursive.js[tag=snippet,indent=0]
----

The implementation above does the job, but what's the runtime?
For that, let's take a look at the job performed calculating the `fib(5)` number. Since `fib(5) = fib(4) + fib(3)`, we need to find the answer for `fib(4)` and `fib(3)`. We do that recursively until we reach the base cases of `fib(1)` and `fib(0)`. If we represent the calls in a tree, we would have the following:

// http://bit.ly/2UmwzZV
[graphviz, Recursive fibonacci call tree, png]
....
graph G {
    "fib(5)" -- { "fib(4)", "fib(3)" }
    "fib(4)" -- { "fib(3)*", "fib(2)" }
    "fib(3)" -- { "fib(2)*", "fib(1)" }
    "fib(2)" -- { "fib(1)*", "fib(0)" }
    "fib(2)*" -- { "fib(1)***", "fib(0)*" }
    "fib(3)*" -- { "fib(2)**", "fib(1)**" }
    "fib(2)**" -- { "fib(1)****", "fib(0)**" }

    // red colors
    "fib(0)*" [color="#FF5252"];
    "fib(0)**" [color="#FF5252"];
    "fib(1)*" [color="#FF5252"];
    "fib(1)**" [color="#FF5252"];
    "fib(1)***" [color="#FF5252"];
    "fib(1)****" [color="#FF5252"];
    "fib(2)*" [color="#FF5252"];
    "fib(2)**" [color="#FF5252"];
    "fib(3)*" [color="#FF5252"];
}
....

In the diagram, we see the two recursive calls needed to compute each number. So if we follow the _O(branches^depth^)_ we get O(2^n^). [big]#üê¢#

NOTE: Fibonacci is not a perfect binary tree since some nodes only have one children instead of two. The exact runtime for recursive Fibonacci is _O(1.6^n^)_ (still exponential time complexity).

An exponential time complexity is pretty bad. Can we do better?

In the call tree you can notice that every element in red and with asterisks `*` it's called more than once. We are repeating calculations too many times!

[quote, Dynamic Programming]
Those who cannot rememeber the past are condemned to repated it.

When we have recursive functions doing duplicated work is the perfect place for dynamic programming optimization. We can save (or cache) the results of previous operations and speed up the program a lot.

.Recursive Fibonacci Implemenation using Dynamic Programming
[source, javascript]
----
include::{codedir}/algorithms/fibanacci-dynamic-programming.js[tag=snippet,indent=0]
----

This implementation checks if we already calculated the value in the past, if not it will save it for later use.

[graphviz, Recursive Fibonacci call tree with dp, svg]
....
graph G {
    "fib(5)" -- { "fib(4)" }
    "fib(4)" -- { "fib(3)" }
    "fib(3)" -- { "fib(2)" }
    "fib(2)" -- { "fib(1)", "fib(0)" }
}
....

This looks pretty linear now and so its runtime _O(n)_!

TIP: Saving previous results for later is a technique called "memoization" and is very common to optimize recursive algorithms with exponential time complexity.
