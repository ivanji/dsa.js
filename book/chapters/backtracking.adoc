= Backtracking

Backtracking algorithms are used to find *all (or some)* solutions that satisfy a contraint.

Bracktracking builds a solution step by step using recursion.
If during the process it realizes a given path is not going to lead to a solution,
it stops and step back (backtracking) to try a different alternative.

Some examples that use backtracking is a solving Sudoku/crosswords puzzle, and graph operations.

ifndef::backend-pdf[]
image:Sudoku_solved_by_bactracking.gif[]
endif::backend-pdf[]

Listing all possible solutions might sound like a brute force.
However, is not the same.
Backtracking algorithms are faster than brute force one.

.Brute Force vs Backtracking Algorithms
****
*Brute force* evaluates every possiblity.
*Bracktracking* is an optimized brute force.
It stops evaluating a path as soon as some of the conditions are broken and move on to the next.
However, it an only be applied if a quick test can be run to tell if a candidate will contribute to a valid solution.
****

== How to develop Backtracking algorithms?

Backtracking algorithms can be tricky to get right or reason about but we are going to follow this recipe to make it easier.

.Steps to create backtracking algorithms
. Iterate through all the elements in the input
. Make a change
. Call recursive function
. Test if the current change is a solution
. Revert back the change (backtracking)

Let's do an exercise to explain better how backtracking works.

// https://leetcode.com/problems/combination-sum/description/

== Permutations

> Return all the permutations (without repetitions) of a given word.

For instace, if are given the word `art` we can have the following permutions

----
[ [ 'art' ],
  [ 'atr' ],
  [ 'rat' ],
  [ 'rta' ],
  [ 'tra' ],
  [ 'tar' ] ]
----


We already solved this problem using an <<Getting all permutations of a word, iterative program>>, now let's do it using backtracking.


[graphviz, Recursive Fibonacci call tree with dp, svg]
....
digraph g {
  node [shape = record,height=.1];

  art[label = "<f0> A|<f1> R|<f2> T"];
  art1[label = "<f0> A|<f1> R|<f2> T"];
  art2[label = "<f0> A|<f1> R|<f2> T", color="red"];
  atr[label = "<f0> A|<f1> T|<f2> R", color="red"];
  rat[label = "<f0> R|<f1> A|<f2> T"];
  rat1[label = "<f0> R|<f1> A|<f2> T", color="red"];
  rta[label = "<f0> R|<f1> T|<f2> A", color="red"];
  tra[label = "<f0> T|<f1> R|<f2> A"];
  tra1[label = "<f0> T|<f1> R|<f2> A", color="red"];
  tar[label = "<f0> T|<f1> A|<f2> R", color="red"];

  art:f0 -> art1:f0 [ label = "1. swap A/A"];
  art1:f0 -> art2:f0 [ label = "2. swap R/R"];
  art2:f2 -> art1:f1 [ label = "3.", color="grey", fontcolor="grey"];
  art1:f2 -> atr:f0 [ label = "4. swap R/T"];
  atr:f2 -> art1:f2  [ label = "5.", color="grey", fontcolor="grey"];
  art1:f1 -> art:f0  [ label = "6.", color="grey", fontcolor="grey"];

  art:f1 -> rat:f0 [ label = "7. swap A/R"];
  rat:f0 -> rat1:f0 [ label = "8. swap A/A"];
  rat1:f2 -> rat:f1 [ label = "9.", color="grey", fontcolor="grey"];
  rat:f2 -> rta:f0 [ label = "10. swap A/T"];
  rta:f2 -> rat:f2 [ label = "11.", color="grey", fontcolor="grey"];
  rat:f2 -> art:f2 [ label = "12.", color="grey", fontcolor="grey"];

  art:f2 -> tra:f0 [ label = "13. swap A/T"];
  tra:f0 -> tra1:f0 [ label = "14. swap R/R"];
  tra1:f2 -> tra:f2 [ label = "15.", color="grey", fontcolor="grey"];
  tra:f2 -> tar:f0 [ label = "16. swap R/A"];
  tar:f2 -> tra:f2 [ label = "17.", color="grey", fontcolor="grey"];
  tra:f2 -> art:f2 [ label = "18.", color="grey", fontcolor="grey"];
}
....
















// == Finding largest sum

// [graphviz, Find largest sum, svg]
// ....
// graph G {
//   5 -- 3 [color="#B8E986", penwidth=2]
//   5 -- 7 [color="#FF5252", penwidth=2]
//   3 -- 87 [color="#B8E986", penwidth=2]
//   3 -- 1
//   7 -- 2
//   7 -- 4 [color="#FF5252", penwidth=2]

//   label="Optimal vs. Greedy path"
// }
// ....

// https://medium.com/leetcode-patterns/leetcode-pattern-3-backtracking-5d9e5a03dc26
// https://leetcode.com/problems/subsets/
